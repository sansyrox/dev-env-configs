"use strict";
// Copyright (c) jdneo. All rights reserved.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fse = require("fs-extra");
const path = require("path");
const vscode = require("vscode");
const leetCodeChannel_1 = require("../leetCodeChannel");
const leetCodeExecutor_1 = require("../leetCodeExecutor");
const leetCodeManager_1 = require("../leetCodeManager");
const shared_1 = require("../shared");
const uiUtils_1 = require("../utils/uiUtils");
const workspaceUtils_1 = require("../utils/workspaceUtils");
const wsl = require("../utils/wslUtils");
const leetCodeSolutionProvider_1 = require("../webview/leetCodeSolutionProvider");
const list = require("./list");
function showProblem(node) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!node) {
            return;
        }
        yield showProblemInternal(node);
    });
}
exports.showProblem = showProblem;
function searchProblem() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!leetCodeManager_1.leetCodeManager.getUser()) {
            uiUtils_1.promptForSignIn();
            return;
        }
        const choice = yield vscode.window.showQuickPick(parseProblemsToPicks(list.listProblems()), {
            matchOnDetail: true,
            placeHolder: "Select one problem",
        });
        if (!choice) {
            return;
        }
        yield showProblemInternal(choice.value);
    });
}
exports.searchProblem = searchProblem;
function showSolution(node) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!node) {
            return;
        }
        const language = yield fetchProblemLanguage();
        if (!language) {
            return;
        }
        try {
            let solution = yield leetCodeExecutor_1.leetCodeExecutor.showSolution(node, language);
            // remove backslash in espaced \'...\'(generated by leetcode's database)
            solution = solution.replace(/\\'/g, "'");
            yield leetCodeSolutionProvider_1.leetCodeSolutionProvider.show(solution, node);
        }
        catch (error) {
            yield uiUtils_1.promptForOpenOutputChannel("Failed to fetch the top voted solution. Please open the output channel for details.", uiUtils_1.DialogType.error);
        }
    });
}
exports.showSolution = showSolution;
// SUGGESTION: group config retriving into one file
function fetchProblemLanguage() {
    return __awaiter(this, void 0, void 0, function* () {
        const leetCodeConfig = vscode.workspace.getConfiguration("leetcode");
        let defaultLanguage = leetCodeConfig.get("defaultLanguage");
        if (defaultLanguage && shared_1.languages.indexOf(defaultLanguage) < 0) {
            defaultLanguage = undefined;
        }
        const language = defaultLanguage || (yield vscode.window.showQuickPick(shared_1.languages, { placeHolder: "Select the language you want to use", ignoreFocusOut: true }));
        // fire-and-forget default language query
        (() => __awaiter(this, void 0, void 0, function* () {
            if (language && !defaultLanguage && leetCodeConfig.get("showSetDefaultLanguageHint")) {
                const choice = yield vscode.window.showInformationMessage(`Would you like to set '${language}' as your default language?`, uiUtils_1.DialogOptions.yes, uiUtils_1.DialogOptions.no, uiUtils_1.DialogOptions.never);
                if (choice === uiUtils_1.DialogOptions.yes) {
                    leetCodeConfig.update("defaultLanguage", language, true /* UserSetting */);
                }
                else if (choice === uiUtils_1.DialogOptions.never) {
                    leetCodeConfig.update("showSetDefaultLanguageHint", false, true /* UserSetting */);
                }
            }
        }))();
        return language;
    });
}
function showProblemInternal(node) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const language = yield fetchProblemLanguage();
            if (!language) {
                return;
            }
            // SUGGESTION: group config retriving into one file
            const leetCodeConfig = vscode.workspace.getConfiguration("leetcode");
            let outDir = yield workspaceUtils_1.selectWorkspaceFolder();
            let relativePath = (leetCodeConfig.get("outputFolder") || "").trim();
            const matchResult = relativePath.match(/\$\{(.*?)\}/);
            if (matchResult) {
                const resolvedPath = yield resolveRelativePath(matchResult[1].toLocaleLowerCase(), node, language);
                if (!resolvedPath) {
                    leetCodeChannel_1.leetCodeChannel.appendLine("Showing problem canceled by user.");
                    return;
                }
                relativePath = resolvedPath;
            }
            outDir = path.join(outDir, relativePath);
            yield fse.ensureDir(outDir);
            const originFilePath = yield leetCodeExecutor_1.leetCodeExecutor.showProblem(node, language, outDir);
            const filePath = wsl.useWsl() ? yield wsl.toWinPath(originFilePath) : originFilePath;
            yield vscode.window.showTextDocument(vscode.Uri.file(filePath), { preview: false });
        }
        catch (error) {
            yield uiUtils_1.promptForOpenOutputChannel("Failed to show the problem. Please open the output channel for details.", uiUtils_1.DialogType.error);
        }
    });
}
function parseProblemsToPicks(p) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const picks = (yield p).map((problem) => Object.assign({}, {
                label: `${parseProblemDecorator(problem.state, problem.locked)}${problem.id}.${problem.name}`,
                description: "",
                detail: `AC rate: ${problem.passRate}, Difficulty: ${problem.difficulty}`,
                value: problem,
            }));
            resolve(picks);
        }));
    });
}
function parseProblemDecorator(state, locked) {
    switch (state) {
        case shared_1.ProblemState.AC:
            return "$(check) ";
        case shared_1.ProblemState.NotAC:
            return "$(x) ";
        default:
            return locked ? "$(lock) " : "";
    }
}
function resolveRelativePath(value, node, selectedLanguage) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (value) {
            case "tag":
                if (node.tags.length === 1) {
                    return node.tags[0];
                }
                return yield vscode.window.showQuickPick(node.tags, {
                    matchOnDetail: true,
                    placeHolder: "Multiple tags available, please select one",
                    ignoreFocusOut: true,
                });
            case "language":
                return selectedLanguage;
            case "difficulty":
                return node.difficulty;
            default:
                const errorMsg = `The config '${value}' is not supported.`;
                leetCodeChannel_1.leetCodeChannel.appendLine(errorMsg);
                throw new Error(errorMsg);
        }
    });
}
//# sourceMappingURL=show.js.map